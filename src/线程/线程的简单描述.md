####  进程和线程的简单描述

​     1.1 进程可以理解为一个个正在执行的应用程序，进程是一个具有一定独立功能的程序在一个数据集上的一次动态执行的过程，是操作系统进行资源分配和调度的一个独立单位
​     1.2 线程是操作系统能够进行运算调度的最小单位。它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，
​     多条线程并行执行不同的任务

    进程与线程的区别：进程只是一个动态的概念，代表的是程序代码在一个数据集上的一次运行过程。进程的主要作用就是获取到操作系统给它分配的硬件资源：包括用于存放程序正文、
                  数据的磁盘和内存地址空间，以及在运行时所需要的I/O设备，已打开的文件，信号量等。具体完成任务的是进程管理的线程。
    一个进程至少包含一个线程。

#### 实现线程有两个方式: 

​               1.继承Thread类 
​               2.实现Runnable接口  
​               一般都是使用实现，继承的局限性比较大
​               
​               
  Dome01 是继承 
  Dome02 是实现     

#### 总结描述


  虽然在代码中 numberThread.start(); 写在了 letterThread.start(); 的前面，但是不代表 numberThread 就一定先于 letterThread 启动；start() 方法只是告诉 CPU 当前线程需要启动，但是什么时候启动，就由 CPU 来决定了，我们就不能再控制它了。我们唯一能做的就是重写 run() 方法来定义一个线程需要完成什么任务和调用 start() 方法来启动这个线程。


在前面的所有示例代码中，我们都重写了 Thread 类或者 Runabble 接口的 run() 方法。并在 run() 方法中定义这个线程需要完成的任务。但是启动线程时不是直接去调用线程实例的 run() 方法，而是通过调用 start() 方法来启动线程。需要注意的是，调用了 start() 方法后，线程可能不会立即执行，它需要等待 cpu 来调度。cpu 在处理该线程的任务时，其实就是执行我们定义的 run() 方法。

如果我们直接在代码中调用线程实例的 run() 方法，是没有多线程的效果的，run() 方法直接就在 main 线程中执行了，与执行一个普通方法没有什么区别。

所以我们应该调用线程实例的 start() 方法来启动一个线程。而不是直接调用 run() 方法。

原文链接：https://blog.csdn.net/llk15884975173/article/details/110677582